Day 1: 10 Problems (Easy Only)
These are ordered from easiest to slightly harder, all teaching fundamental patterns you'll use throughout Blind 75.​

1. Contains Duplicate (LeetCode #217)
Pattern: HashMap/Set
Time: 10-15 minutes
Why: Simplest problem ever - just check if array has duplicates​

javascript
// Given: [1,2,3,1]
// Return: true (1 appears twice)
2. Valid Anagram (LeetCode #242)
Pattern: HashMap for counting
Time: 15 minutes
Why: Teaches character frequency counting​

javascript
// Given: s = "anagram", t = "nagaram"
// Return: true (same letters, different order)
3. Two Sum (LeetCode #1)
Pattern: HashMap for lookup
Time: 15-20 minutes
Why: Most famous interview question, teaches complement logic​

javascript
// Given: [2,7,11,15], target = 9
// Return: [0,1] (2+7=9)
4. Best Time to Buy and Sell Stock (LeetCode #121)
Pattern: Single pass tracking min/max
Time: 20 minutes
Why: Teaches greedy approach with one loop​

javascript
// Given: [7,1,5,3,6,4]
// Return: 5 (buy at 1, sell at 6)
5. Valid Parentheses (LeetCode #20)
Pattern: Stack
Time: 20-25 minutes
Why: Classic stack problem with matching pairs​

javascript
// Given: "()[]{}"
// Return: true (all brackets match)
6. Reverse Linked List (LeetCode #206)
Pattern: Pointer manipulation
Time: 25-30 minutes
Why: Fundamental linked list operation​

javascript
// Given: 1->2->3->4->5
// Return: 5->4->3->2->1
7. Merge Two Sorted Lists (LeetCode #21)
Pattern: Two pointers
Time: 25-30 minutes
Why: Teaches merging logic with pointers​

javascript
// Given: [1,2,4], [1,3,4]
// Return: [1,1,2,3,4,4]
8. Climbing Stairs (LeetCode #70)
Pattern: Dynamic Programming (basic)
Time: 20-25 minutes
Why: First intro to DP, similar to Fibonacci​

javascript
// Given: n = 3 (stairs)
// Return: 3 ways (1+1+1, 1+2, 2+1)
9. Maximum Depth of Binary Tree (LeetCode #104)
Pattern: Tree traversal (DFS/BFS)
Time: 20 minutes
Why: Simplest tree problem, teaches recursion​

javascript
// Given: root = [3,9,20,null,null,15,7]
// Return: 3 (max depth)
10. Linked List Cycle (LeetCode #141)
Pattern: Fast & Slow pointers
Time: 25-30 minutes
Why: Famous two-pointer technique​

javascript
// Given: 3->2->0->-4 (cycle back to 2)
// Return: true